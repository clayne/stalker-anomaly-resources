--[[
    author: Oiltanker

    Usage:
     - do NOT create instances, class is a singelton
     - use global instance 'TerEnum' (global variable)

    In game:
     - in debug mode press following keys:
       - Numpad Enter    to enable debug rendering (particles at spawn points)
       - Numpad +        to deisable debug rendering
]]

--[[
    2D coordinate rule:
     - fist 2  if x <  value.X
     - last 2  if x >= value.X
     - odd   if z <  value.Z
     - even  if z >= value.Z
    3D coordinate rule: -- not used !!
     - fist 4  if x <  value.X
     - last 4  if x >= value.X
     - first and third pair (count cords by 2)   if y <  value.Y
     - second and forth pair (count cords by 2)  if y >= value.Y
     - odd   if z <  value.Z
     - even  if z >= value.Z
]]


local io = require 'io'
local os = require 'os'


TE_levels = {
    'fake_start',
    'jupiter',
    'jupiter_underground',
    'k00_marsh',
    'k01_darkscape',
    'k02_trucks_cemetery',
    'l01_escape',
    'l02_garbage',
    'l03_agroprom',
    'l03u_agr_underground',
    'l04_darkvalley',
    'l04u_labx18',
    'l05_bar',
    'l06_rostok',
    'l07_military',
    'l08_yantar',
    'l08u_brainlab',
    'l09_deadcity',
    'l10_limansk',
    'l10_radar',
    'l10_red_forest',
    'l10u_bunker',
    'l11_hospital',
    'l11_pripyat',
    'l12_stancia',
    'l12_stancia_2',
    'l12u_control_monolith',
    'l12u_sarcofag',
    'l13_generators',
    'l13u_warlab',
    'labx8',
    'pripyat',
    'y04_pole',
    'zaton',
}

local cmd = {}
local function detectOS()
    local os = jit and jit.os or _G._OS
    if os == 'Windows' then
        cmd.delete = 'del '
    elseif os == 'Linux' then
        cmd.delete = 'rm '
    elseif os == 'OSX' then
        cmd.delete = 'rm '
    else
        error('Terrain Enumerator Script | Operating system not supported.')
    end
end
detectOS()

local function fileExists(path)
    if io.open(path, 'r') ~= nil then
        return true
    else
        return false
    end
end
local function fileDelete(path)
    if fileExists(path) then
        return os.execute(cmd.delete .. path) == 0
    else
        return false
    end
end


_G.TEDecision = {
    Ignore  = 0, -- ignore leaf or tree node children
    Select  = 1, -- add leaf to the result
    All     = 2, -- check all node's children
    Left    = 3, -- check node's left child
    Right   = 4, -- check node's right child
}

DefaultPointGap   = 3
DefaultChunkShize = 6


local function fileWriter(file)
    return { write = function(val, isByte)
        if not isByte then file:write(val)
        else file:write(string.char(val)) end
        file:write(string.char(0))
    end }
end


local function _read_cache(pos, cache)
    --[[local size = string.byte(string.sub(cache, pos, pos))
    if size then return pos + 1 + size + 1, string.sub(cache, pos + 1, pos + 1 + size)
    else return #cache + 1, nil end]] -- needs LUA >= 5.2
    local nPos = string.find(cache, '\0', pos)
    if nPos then return nPos + 1, string.sub(cache, pos, nPos - 1)
    else return #cache + 1, nil end
end
local function cacheIterator(cache)
    local i = 1
    local read = nil
    return function()
        i, read = _read_cache(i, cache)
        if read then return read
        else return nil end
    end
end

CParser = {}
function CParser.parse(fmt, cv)
    if fmt == 'b' then
        return string.byte(cv)
    elseif fmt == 'n' or fmt =='i' or fmt == 'f' then
        return tonumber(cv)
    elseif fmt == 's' then
        return cv
    else
        error('CachseParser | FORMAT ERROR: wrong or absent format value')
    end
end


local function newCounter(start, finish, step)
    start = start and start or 1
    finish = finish and finish or math.huge
    step = step and step or 1

    local i = start - 1
    return function()
        if i <= finish then
            i = i + step
            return i
        end
        return nil
    end
end


-- pre-made queries
function TENumberQuery(min, max) -- both optional, then all leaves will be selected, DO NOT use that to get all leaves, use `TerEnum.spawns` instead
    min = min and min or -math.huge
    max = max and max or math.huge

    return function(node) -- (TEIdxNode) -> TEDecision
        if node:isLeaf() then
            if min < node.value and node.value < max then
                return TEDecision.Select
            end
        else
            if min < node.value and node.value < max then
                return TEDecision.All
            elseif node.value > max then
                return TEDecision.Left
            elseif min > node.value then
                return TEDecision.Right
            end
        end
        return TEDecision.Ignore
    end
end

function TEStringQuery(patternNode, patternLeaf) -- patternLeaf optional, default same as patternNode, patternNode defaults to empty string match if not provided
    patternNode = patternNode and patternNode or '^$'
    patternLeaf = patternLeaf and patternLeaf or patternNode

    return function(node) -- (TEIdxNode) -> TEDecision
        if node:isLeaf() then
            if string.find(node.value, patternLeaf) then
                return TEDecision.Select
            end
        else
            if string.find(node.value, patternNode) then
                return TEDecision.All
            end
        end
        return TEDecision.Ignore
    end
end


-- TESpawn class
class 'TESpawn'
function TESpawn:__init(pos, lvid)
    self.pos = pos
    self.lvid = lvid
end


-- TEIdxNode class
class 'TEIdxNode'
function TEIdxNode:__init(value, left, right)
    self.value = value
    self.left = left
    self.right = right
    self.leafId = nil
end

function TEIdxNode:isLeaf()
    return self.leafId ~= nil or (self.left == nil and self.right == nil)
end

-- TEIdxTemplate class
class 'TEIdxTemplate'
function TEIdxTemplate:__init(evalLeaf, decideValue, packValue, unpackValue) -- (required, required, optional, optional)
    self.evalLeaf = evalLeaf -- (sp: TESpawn) -> <index_value> | evaluete index value of the leaf
    self.decideValue = decideValue -- (a: <index_value>, b: <index_value>) -> bool | decide order of the leaf index (e.g. < operator for integers)
    self.packValue = packValue -- (val: <index_value>) -> string | pack value to a string for saving
    self.unpackValue = unpackValue -- (val: string) -> <index_value> | unpack saved string to a index value
end

function TEIdxTemplate:canCache()
    return self.packValue ~= nil and self.unpackValue ~= nil
end

-- TEIdxTree class
class 'TEIdxTree'
function TEIdxTree:__init(teIdxTemplate, leaves, filePath)
    self.teIdxTemplate = teIdxTemplate
    self.leaves = leaves
    self.filePath = filePath

    self.root = nil
    if not self.filePath then
        self:buildTree()
    elseif not self:load(self.filePath) then
        self:buildTree()
        self:write(self.filePath)
    end
end

function TEIdxTree:buildTree()
    -- assign index values to leaf nodes
    local leafIndexValues = {}
    for i = 1, #self.leaves do
        leafIndexValues[i] = {
            id = i,
            val = self.teIdxTemplate.evalLeaf(self.leaves[i])
        }
    end
    table.sort(leafIndexValues, function(a, b) return self.teIdxTemplate.decideValue(a.val, b.val) end)

    -- build tree using a queue
    local queue = { { l = 1, r = #leafIndexValues, cc = function(n) self.root = n end } }
    local loop = function(l, r, cc)
        if l ~= r then
            local middle = math.floor((l + r) / 2)
            local node = TEIdxNode(leafIndexValues[middle].val, nil, nil)
            table.insert(queue, { l = l, r = middle, cc = function(n) node.left = n end })
            table.insert(queue, { l = middle + 1, r = r, cc = function(n) node.right = n end })
            cc(node)
        else
            local node = TEIdxNode(leafIndexValues[l].val, nil, nil)
            node.leafId = leafIndexValues[l].id
            cc(node)
        end
    end
    while #queue > 0 do
        local elem = table.remove(queue, 1)
        loop(elem.l, elem.r, elem.cc)
    end
end

function TEIdxTree:queryTree(query) -- (query: function(TEIdxNode) -> TEDecision) -> leaves[] | collect all leaves that fit the query
    local leafs = {}

    local queue = { self.root }
    local loop = function(node)
        if not node:isLeaf() then
            local decision = query(node)
            if decision == TEDecision.All or decision == TEDecision.Left then table.insert(node.left) end
            if decision == TEDecision.All or decision == TEDecision.Right then table.insert(node.right) end
        else
            if query(node) == TEDecision.Select then
                table.insert(leafs, self.leaves[node.leafId])
            end
        end
    end
    while #queue > 0 do
        local node = table.remove(queue, 1)
        loop(node)
    end

    return leafs
end

function TEIdxTree:write(filePath)
    local file = io.open(filePath, 'w+b')
    if not file then
        log('TEIdxTree | SAVE ERROR: Failed to save index cache.')
        return false
    end

    local fw = fileWriter(file)

    local getIdx = newCounter(1, nil, 1)
    local queue = { { node = self.root, idx = getIdx() } }
    local loop = function(idx, node)
        fw.write(1, true) -- new entry

        fw.write(2, true) -- index
        fw.write(idx)

        fw.write(3, true) -- value
        fw.write(self.teIdxTemplate.packValue(node.value))

        if node:isLeaf() then
            fw.write(4, true) -- leafId
            fw.write(node.leafId)
        else
            local lIdx, rIdx = node.left and getIdx() or nil, node.right and getIdx() or nil

            if lIdx then
                fw.write(5, true) -- left
                fw.write(lIdx)
                table.insert(queue, { node = node.left, idx = lIdx })
            end

            if rIdx then
                fw.write(6, true) -- right
                fw.write(rIdx)
                table.insert(queue, { node = node.right, idx = rIdx })
            end
        end
    end
    while #queue > 0 do
        local elem = table.remove(queue, 1)
        loop(elem.idx, elem.node)
    end

    file:close()
    return true
end

function TEIdxTree:load(filePath)
    local file = io.open(filePath, 'rb')
    if not file then return false end

    local cache = file:read('*all')
    if #cache == 0 then
        log('TEIdxTree | LOAD ERROR: index file is empty.')
        return false
    end
    file:close()

    local nodeTable = {}
    local idx = nil
    local value = nil
    local leafId = nil
    local leftIdx = nil
    local rightIdx = nil

    local state = nil
    for read in cacheIterator(cache) do
        if not state then
            local bVal = CParser.parse('b', read)
            if bVal == 1 then -- new entry
                state = nil
                if idx then
                    if value and (leafId or (leftIdx and rightIdx)) then
                        if leafId then -- leaf node
                            nodeTable[idx] = TEIdxNode(self.teIdxTemplate.unpackValue(value), nil, nil)
                            nodeTable[idx].leafId = leafId
                        else -- tree node
                            nodeTable[idx] = TEIdxNode(self.teIdxTemplate.unpackValue(value), leftIdx, rightIdx)
                        end
                    else
                        log('TEIdxTree | LOAD ERROR: index file format error - malformed entry.')
                        return false
                    end
                end
                idx = nil
                value = nil
                leafId = nil
                leftIdx = nil
                rightIdx = nil
            elseif bVal == 2 then -- idx
                state = 2
            elseif bVal == 3 then -- value
                state = 3
            elseif bVal == 4 then -- leafId
                state = 4
            elseif bVal == 5 then -- leftIdx
                state = 5
            elseif bVal == 6 then -- rightIdx
                state = 6
            end
        else
            if state == 2 then
                state = nil
                idx = CParser.parse('i', read)
            elseif state == 3 then
                state = nil
                value = CParser.parse('s', read)
            elseif state == 4 then
                state = nil
                leafId = CParser.parse('i', read)
            elseif state == 5 then
                state = nil
                leftIdx = CParser.parse('i', read)
            elseif state == 6 then
                state = nil
                rightIdx = CParser.parse('i', read)
            else
                log('TEIdxTree | LOAD ERROR: index file format error - malformed file.')
                return false
            end
        end
    end

    for i,node in pairs(nodeTable) do
        if node.leafId ~= nil then -- leaf node
            -- do nothing
        else -- tree node
            if node.left then node.left = nodeTable[node.left] end
            if node.right then node.right = nodeTable[node.right] end
            if node.left == nil and node.right == nil then
                log('TEIdxTree | LOAD ERROR: missing node with the index of ' .. i .. '.')
                return false
            end
        end
    end
    self.root = nodeTable[1]
    nodeTable = nil -- free memory?

    return true
end

-- TEChunk class
class 'TEChunk'
function TEChunk:__init(spawns) -- (spawns: TESpawn[]) | only those that belong to this chunk
    self.spawns = spawns
end

function TEChunk:closest(pos) -- returns closest point
    local minDist = math.huge
    local res = nil
    for _,sp in ipairs(self.spawns) do
        local dist = math.sqrt((sp.pos.x - pos.x)^2 + (sp.pos.y - pos.y)^2 + (sp.pos.z - pos.z)^2)
        if minDist > dist then
            minDist = dist
            res = sp
        end
    end
    return res
end

-- TEChunkTable class
class 'TEChunkMap'
function TEChunkMap:__init(spawns, size) -- (spawns: TESpawn[], chunkSize: int) | all spawns and chunk size to devide them into
    self.size = size and size or DefaultChunkShize
    self.chunks = {}
    self.min_x, self.max_x = math.huge, -math.huge
    self.min_z, self.max_z = math.huge, -math.huge

    for _, sp in ipairs(spawns) do
        local x = math.floor(sp.pos.x / size)
        local z = math.floor(sp.pos.z / size)
        self.min_x, self.max_x = math.min(self.min_x, x), math.max(self.max_x, x)
        self.min_z, self.max_z = math.min(self.min_z, z), math.max(self.max_z, z)
        if self.chunks[x] == nil then self.chunks[x] = {} end
        if self.chunks[x][z] == nil then self.chunks[x][z] = TEChunk({sp})
        else table.insert(self.chunks[x][z].spawns, sp) end
    end
end

function TEChunkMap:closest(pos) -- (pos: vector) -> TESpawn | returns closest point
    local x = math.floor(pos.x / self.size)
    local z = math.floor(pos.z / self.size)
    for i = 0, math.max(self.max_x - self.min_x, self.max_z - self.min_z) do
        for dx = math.max(-i, self.min_x), math.min(i, self.max_x) do
            for dz = math.max(-i, self.min_z), math.min(i, self.max_z) do
                local cx, cz = x + dx, z + dz
                local chunk = self.chunks[cx] and self.chunks[cx][cz]
                if chunk then
                    local closest = chunk:closest(pos)
                    if closest then return closest end
                end
            end
        end
    end
    return nil
end

function TEChunkMap:chunk(pos)
    local x = math.floor(pos.x / self.size)
    local z = math.floor(pos.z / self.size)
    return self.chunks[x] and self.chunks[x][z]
end

-- TerrainEnumerator class
class 'TerrainEnumerator'
function TerrainEnumerator:__init(sampleStep)
    self.currentLevel = nil
    self.isLevelLoaded = false
    self.sampleStep = sampleStep and sampleStep or DefaultPointGap
    self._chunkSize = sampleStep and sampleStep * 2 or DefaultChunkShize

    self.debugRender = false
    self.debugParticles = {}
    self.debugPFreq = 0.5 -- in seconds

    -- cacheFiles
    self.cacheDist = '_te_caches\\'
    self.pointFile = self.cacheDist .. 'points_'

    -- spawns and r-tree
    self.spawns = {}
    self.map = nil

    -- indexation
    self.idxTemplates = {}
    self.idxTrees = {}
end

-- Methods
function TerrainEnumerator:addIndex(name, teIdxTemplate) -- errors because it's addon development / installation level incompatibility
    if string.find(name, '[^%a%d_]') ~= nil then
        error('TerrainEnumerator | INDEX ERROR: name must not contain any characters apart from A-z, 0-9 and \'_\'.')
    end
    if self.idxTemplates[name] ~= nil then
        error('TerrainEnumerator | INDEX ERROR: duplicate index name.')
    end
    self.idxTemplates[name] = teIdxTemplate
    if self.isLevelLoaded and self.currentLevel ~= nil then
        log('TerrainEnumerator | indexing ' .. name)
        local fileName = self.idxTemplates[name]:canCache() and self.cacheDist .. name .. '_' .. self.currentLevel or nil
        self.idxTrees[name] = TEIdxTree(self.idxTemplates[name], self.spawns, fileName)
    end
end

function TerrainEnumerator:removeIndex(name, clearCache)
    clearCache = clearCache and true or false -- force boolean
    if self.idxTemplates[name] == nil then
        log('TerrainEnumerator | INDEX ERROR: no index with the name \'' .. name .. '\'.')
        return false
    end
    if clearCache then self:clearIdxCache(name) end
    self.idxTrees[name] = nil
    self.idxTemplates[name] = nil
    return true
end

function TerrainEnumerator:queryIndex(name, query) -- (query: function(TEIdxNode) -> TEDecision) -> leaves[] | collect all leaves that fit the query
    if self.idxTemplates[name] == nil then
        error('TerrainEnumerator | INDEX ERROR: no index with the name \'' .. name .. '\'.') -- development error
        return nil
    end
    return self.idxTrees[name]:query(query)
end

function TerrainEnumerator:clearIdxCache(name)
    local chachePrefix = self.cacheDist .. name .. '_'
    for _,lvl in ipairs(TE_levels) do
        local cFile = chachePrefix .. lvl
        fileDelete(cFile)
    end
end

function TerrainEnumerator:enumLevel(reEnum) -- enumerates current level
    reEnum = reEnum and true or false -- force boolean
    if not reEnum and (self.currentLevel == level.name() or self:loadLvlCfg(level.name())) then
        self.currentLevel = level.name()
        return
    end

    self.currentLevel = level.name()
    self.spawns = {}
    self.idxTrees = {}

    -- setup
    local bbMin = level.get_bounding_volume().min
    local bbMax = level.get_bounding_volume().max

    local y_lvls = {
        bbMax.y,
        (bbMax.y + bbMin.y) / 2,
        bbMin.y
    }

    -- enumeration (at least some freeze guaranteed)
    local vCount = 0
    local vTotal = 0

    local memGorging = {}
    local iterX, iterZ = math.floor((bbMax.x - bbMin.x) / self.sampleStep - 1), math.floor((bbMax.z - bbMin.z) / self.sampleStep - 1)
    for _,y in ipairs(y_lvls) do
        for x=0,iterX do
            for z=0,iterZ do
                vTotal = vTotal + 1
                local pos = vector():set(bbMin.x  + (x * self.sampleStep), y, bbMin.z + (z * self.sampleStep))

                local lvid = level.vertex_id(pos)
                if lvid > 0 then
                    pos = level.vertex_position(lvid) -- set to level vertex position

                    if math.abs(pos.x) + math.abs(pos.y) + math.abs(pos.z) > 0.1 then -- to high eps? well false negative <<< false positive
                        local duplicate = false

                        local function round(x)
                            local floor = math.floor(x)
                            if (x - floor) >= 0.5 then return floor
                            else return math.ceil(x) end
                        end
                        local ofX = round(pos.x * 10) / 10
                        local ofY = round(pos.y * 10) / 10
                        local ofZ = round(pos.z * 10) / 10
                        local ofStr = table.concat({ofX, ofY, ofZ}, '|')
                        if memGorging[ofStr] then duplicate = true
                        else memGorging[ofStr] = true end

                        if not duplicate then
                            vCount = vCount + 1 -- count valid
                            table.insert(self.spawns, TESpawn(pos, lvid))
                        end
                    end
                end
            end
        end
    end
    memGorging = nil -- free memory?

    -- log stats & bild map
    log('TerrainEnumerator | valid spawns: ' .. tostring(vCount) .. ' / ' .. tostring(vTotal))
    self.map = TEChunkMap(self.spawns, self._chunkSize)

    -- calculate indexes
    for name,_ in pairs(self.idxTemplates) do
        log('TerrainEnumerator | indexing ' .. name)
        local fileName = self.idxTemplates[name]:canCache() and self.cacheDist .. name .. '_' .. self.currentLevel or nil
        self.idxTrees[name] = TEIdxTree(self.idxTemplates[name], self.spawns, fileName)
    end

    -- save in config
    self:saveLvlCfg()
end

function TerrainEnumerator:_parsePointsCache(cache)
    local pos = {}
    local lvid = nil

    local state = nil
    for read in cacheIterator(cache) do
        if not state then
            local bVal = CParser.parse('b', read)
            if bVal == 1 then -- new entry
                state = nil
                if lvid then -- create if previuos exists
                    if #pos == 3 then
                        table.insert(self.spawns, TESpawn(vector():set(pos[1], pos[2], pos[3]), lvid))
                        pos = {}
                        lvid = nil
                    else -- format error
                        log('TerrainEnumerator | LOAD ERROR: points file format error - malformed entry.')
                        self.spawns = {}
                        return false
                    end
                end
            elseif bVal == 2 then -- position number
                state = 2
            elseif bVal == 3 then -- level vertex id
                state = 3
            else -- format error
                log('TerrainEnumerator | LOAD ERROR: points file format error - unkwnon symbol \\' .. bVal .. '.')
                self.spawns = {}
                return false
            end
        else
            if state == 2 then
                state = nil
                table.insert(pos, CParser.parse('f', read))
            elseif state == 3 then
                state = nil
                lvid = CParser.parse('i', read)
            else
                log('TerrainEnumerator | LOAD ERROR: points file format error - malformed file.')
                self.spawns = {}
                return false
            end
        end
    end

    return true
end

function TerrainEnumerator:loadLvlCfg(lvlName)
    self.spawns = {}
    self.idxTrees = {}

    local pointFile = io.open(self.pointFile .. lvlName, 'rb')
    if not pointFile then return false end

    -- reading spawns
    local pCache = pointFile:read('*all')
    if #pCache == 0 then
        log('TerrainEnumerator | LOAD ERROR: points file is empty.')
        return false
    end
    pointFile:close()
    if not self:_parsePointsCache(pCache) then return false end
    self.map = TEChunkMap(self.spawns, self._chunkSize)

    -- load indexes
    for name,_ in pairs(self.idxTemplates) do
        log('TerrainEnumerator | indexing ' .. name)
        local fileName = self.idxTemplates[name]:canCache() and self.cacheDist .. name .. '_' .. lvlName or nil
        self.idxTrees[name] = TEIdxTree(self.idxTemplates[name], self.spawns, fileName)
    end

    return true
end

function TerrainEnumerator:saveLvlCfg()
    if not self.spawns then
        log('TerrainEnumerator | GENERATION ERROR: failed to generate spawns or an index tree')
        return
    end

    local lvlName = level.name()
    local pointFile = io.open(self.pointFile .. lvlName, 'w+b')

    if not pointFile then
        error('TerrainEnumerator | SAVE ERROR: could not create files')
        return
    end

    -- wrire points
    local fw = fileWriter(pointFile)
    for i=1,#self.spawns do
        local sp = self.spawns[i]
        fw.write(1, true) -- new entry

        fw.write(2, true) -- position x
        fw.write(sp.pos.x)
        fw.write(2, true) -- position y
        fw.write(sp.pos.y)
        fw.write(2, true) -- position z
        fw.write(sp.pos.z)

        fw.write(3, true) -- level vertex id
        fw.write(sp.lvid)
    end

    pointFile:close()
end

function TerrainEnumerator:getClosest(vec) -- get closest spawn position to a vector
    return self.map:closest(vec)
end

-- Debug generated spawn points
function TerrainEnumerator:debugShowParticles()
    if not self.debugRender then return true
    else ResetTimeEvent("spawn_particle_update", "spawn_particle_update", self.debugPFreq) end


    if #self.spawns ~= #self.debugParticles then
        self.debugParticles = {}
        for i=1,#self.spawns do
            --_samples_particles_\glow_01
            --_samples_particles_\glow_03
            --anomaly2\effects\a_test_glow
            self.debugParticles[i] = particles_object([[anomaly2\effects\a_test_glow]])
        end
    end

    for i=1,#self.spawns do
        if self.debugParticles[i]:playing() then self.debugParticles[i]:stop() end
        self.debugParticles[i]:play_at_pos(self.spawns[i].pos)
    end
end

-- Callbacks
function TerrainEnumerator:CC_OnLevelLoaded() -- terain and stuff
    self.isLevelLoaded = true
    self:enumLevel()
end

function TerrainEnumerator:CC_OnBeforeLevelChanging()
    self.debugRender = false
    self.isLevelLoaded = false
end

function TerrainEnumerator:CC_OnKeyPress(key)
    if not DEV_DEBUG then return end

    if key == DIK_keys.DIK_NUMPADENTER then
        self.debugRender = true
        CreateTimeEvent('spawn_particle_update', 'spawn_particle_update', self.debugPFreq, self.debugShowParticles, self)
    elseif key == DIK_keys.DIK_ADD then
        self.debugRender = false
    end
end

_G.TerEnum = TerrainEnumerator()
TerEnum:addIndex('random', TEIdxTemplate(
    function(sp)   -- evalLeaf     (sp: TESpawn) -> <index_value> | evaluete index value of the leaf
        return math.random()
    end,
    function(a, b) -- decideValue  (a: <index_value>, b: <index_value>) -> bool | decide order of the leaf index (e.g. < operator for integers)
        return a < b
    end,
    function(val)  -- packValue    (val: <index_value>) -> string | pack value to a string for saving
        return tostring(val)
    end,
    function(val)  -- unpackValue  (val: string) -> <index_value> | unpack saved string to a index value
        return tonumber(val)
    end
))

function on_game_start()
    RegisterScriptCallback('on_key_press', function(key) TerEnum:CC_OnKeyPress(key) end)
    RegisterScriptCallback('actor_on_first_update', function() TerEnum:CC_OnLevelLoaded() end)
    RegisterScriptCallback('on_before_level_changing', function() TerEnum:CC_OnBeforeLevelChanging() end)
end